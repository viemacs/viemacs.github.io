<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Designs on Viemacs Notes</title>
    <link>./design/</link>
    <description>Recent content in Designs on Viemacs Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="./design/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Design</title>
      <link>./design/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./design/access/</guid>
      <description> Design </description>
    </item>
    
    <item>
      <title>Design</title>
      <link>./design/design-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./design/design-pattern/</guid>
      <description> Design Pattern 设计模式是经过验证的代码设计经验的总结。其关注点是代码的可重用、易理解、可靠性。
设计模式的基本类型有：创建、结构、行为。
设计原则 设计模式是设计原则的实现，以达到代码的复用和可维护。
 单一职责原则 Single Responsibility Principle
 开闭原则 Open Closed Principle
Software entities should be open for extension, but closed for modification. 模块应对扩展开放，对修改关闭。
 里氏代换原则 Liskov Substitution Principle
子类可代替父类运行。这种代换是继承利用的基础。
 依赖倒转原则 Dependency Inversion Principle
子类代替父类后，程序的行为不变化。这是面向对象设计的标志。
 接口隔离原则 Interface Segregation Principle
各接口间互不影响。每个接口可以做而且仅做自己需要做和应该做的事。不是所有可以做的事都应放到一个接口中。
 合成聚合复用原则 Composite/Aggregate Reuse Principle
应优先使用合成与聚合，而不是继承。合成复用原则是在新对象中使用已有对象，新对象通过向已有对象委派来复用已有功能。使各个类之间的联系尽量少，才好提高扩展性和可维护性。
 迪米特最小知识原则 Principle of Least Knowledge
各个对象对其他对象的了解应尽可能少。
  在解决问题时，设计模式可以帮忙我们在更高的抽象层次上工作。先是对问题的分析，了解问题中的因果关系，看使用模式的先决条件是否满足。然后根据分析给出解决方案。解决方案不是具体的设计和实现，而是对问题做抽象描述，表明如何用元素的组合而解决问题。
创建  单例模式 Singleton 下一个类仅有一个实例和一个全局访问点。要注意单例模式在使用多线程、序列化、类装载器（multi-threading, serialization, class loaders）时的问题。 工厂模式 Factory Method 定义一个用于创建对象的接口，由子类确定实例化哪个对象，使类的实例化延后到子类。 抽象工厂模式 Abstract Factory 不指定具体的类，仅提供一个创建一组相关/相依赖对象的接口。 建造者模式 Builder 将（复杂）对象的构建和表示分离，使同样的构建过程可以创建不同的表示。 原型模式 Prototype 用原型的实例来指定所创建对象的种类，并通过复制这个原型来创建新的对象。  结构**  适配器模式 Adapter 将一个类的接口转换成另一个接口，使接口不兼容的类可以一起工作。 桥接模式 Bridge 将类的抽象部分和实现部分分离，分别独立改变。 装饰模式 Decorator 向对象动态增加额外职责。比生成子类更灵活地扩展一个类的功能。 组合模式 Composite 将对象组合成表达整体与部分关系的树形层次结构，使单个对象和复合对象在使用上一致。 外观模式 Facade 为子系统的一组接口提供一致的界面，定义高层接口，增加子系统的易用性。 享元模式 Flyweight 用共享技术有效支持大量细粒度的对象。 代理模式 Proxy 为其他对象提供代理，用代理来控制对象的访问。  行为**  模版模式 Template Method 定义方法中的算法骨架，将部分步骤延后到子类中，使子类不改变算法结构而重定义算法中的某些步骤。 命令模式 Command 将请求封装为对象，？？使用不同请求来对接收者进行参数化？？，可将请求排队、取消、记录日志。 迭代器模式 观察者模式 Observer 在对象间建立一对多的依赖关系，当一个对象改变时，所有依赖于它的对象都自动刷新。 中介者模式 Mediator 封装一系列的对象交互，使各对象不需要显示相互引用，松耦合，并可以独立改变对象间的交互。 备忘录模式 Memento 不破坏对象的封装，捕获对象内部的状态并在对象外部保存，这可将对象恢复到保存时的状态。 解释器模式 Interpreter 定义一个给定语言的文法表示和解释器，来表示解释此语言的语句。 状态模式 State 允许对象在内部状态改变时改变行为，像是对象所属的类发生了变化。 策略模式 Strategy 定义并封装一系列的算法，并使它们可相互替换，使算法变化独立于使用者。 责任链模式 Chain of Responsibility 解耦请求的发送者和接收者。将多个可能处理请求的对象连成一条链，请求在链上传递，直到有一个对象处理它。 访问者模式 Visitor 表示对一个对象中元素的操作，可以定义作用于元素的新操作而不改变元素的类。  </description>
    </item>
    
  </channel>
</rss>