<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Viemacs Notes</title>
    <link>./</link>
    <description>Recent content on Viemacs Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 22 Jul 2017 11:51:17 +0800</lastBuildDate>
    
	<atom:link href="./index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Algorithm</title>
      <link>./algorithm/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./algorithm/access/</guid>
      <description> Algorithm </description>
    </item>
    
    <item>
      <title>Algorithm</title>
      <link>./algorithm/huffman/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./algorithm/huffman/</guid>
      <description>Huffman Encoding class Node(object): def __init__(self, symbol = &amp;#39;&amp;#39;, weight = 0, left = None, right = None): self.symbol, self.weight, self.left, self.right = symbol, weight, left, right if (left and right): self.weight = left.weight + right.weight def result(self, code = &amp;#39;&amp;#39;): r = [] self.symbol and r.append((self.symbol, self.weight, code)) self.left and r.extend(self.left.result(code + &amp;#39;0&amp;#39;)) self.right and r.extend(self.right.result(code + &amp;#39;1&amp;#39;)) return r def genHuffman(char, freq): nodeList = [] for i in range(len(char)): nodeList.</description>
    </item>
    
    <item>
      <title>Editor</title>
      <link>./editor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./editor/</guid>
      <description>Editor Emacs Emacs Config File init.el</description>
    </item>
    
    <item>
      <title>Editor</title>
      <link>./editor/vim_shortcuts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./editor/vim_shortcuts/</guid>
      <description>VIM Shortcuts 退出  w filename: 保存正在编辑的文件filename wq filename: 保存后退出正在编辑的文件filename q：退出不保存。  窗口操作  ctrl+w p: 在两个分割窗口之间来回切换。 ctrl+w j: 跳到下面的分割窗 ctrl+w h: 跳到左边的分割窗。 ctrl+w k: 跳到上面的分割窗。 ctrl+w l: 跳到右边的分割窗。  移动 h,j,k,l: 左，下，上，右。 w: 下一个词的词首。 e:下一个词的词尾。 b:上一个词的词首。 &amp;lt;&amp;gt;: v 模式选中后进行缩进。  跳转 %: 可以匹配{},&amp;quot;&amp;quot;,(),[]之间跳转。 H、M、L：直接跳转到当前屏幕的顶部、中部、底部。 #H：跳转到当前屏的第#行。 #L：跳转到当前屏的倒数第#行。 zt: 当前编辑行置为屏顶。 zz: 当前编辑行置为屏中。 zb: 当前编辑行置为屏底。 G：直接跳转到文件的底部。 gg: 跳转到文件首。 ():跳转到当前的行首、行尾。 {}：向上、向下跳转到最近的空行。 [{：跳转到目前区块开头。 ]}：跳转到目前区块结尾。 0: 跳转到行首。 $: 跳转到行尾。 2$: 跳转到下一行的行尾。 #：跳转到该行的第#个位置。 #G: 15G,跳转到15行。 :#：跳转到#行。 f&#39;n&#39;：跳转到下一个&amp;quot;n&amp;quot;字母后。 ctrl+b: 向后翻一页。 ctrl+f：向前翻一页。 ctrl+u: 向后翻半页。 ctrl+d: 向前翻半页。 ctry+e: 下滚一行。  选择 1.</description>
    </item>
    
    <item>
      <title>Errors</title>
      <link>./errors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./errors/</guid>
      <description>Errors This error section is stored in a separate file, errors.md. DocuAPI allows you to split the single page documentation in as many files as needed. Files are included in the default Hugo page order . One way of ordering the pages is by setting the page `weight` in the front matter. Pages with lower weight will be listed first. The Kittn API uses the following error codes:
   Error Code Meaning     400 Bad Request &amp;ndash; Your request sucks   401 Unauthorized &amp;ndash; Your API key is wrong   403 Forbidden &amp;ndash; The kitten requested is hidden for administrators only   404 Not Found &amp;ndash; The specified kitten could not be found   405 Method Not Allowed &amp;ndash; You tried to access a kitten with an invalid method   406 Not Acceptable &amp;ndash; You requested a format that isn&amp;rsquo;t json   410 Gone &amp;ndash; The kitten requested has been removed from our servers   418 I&amp;rsquo;m a teapot   429 Too Many Requests &amp;ndash; You&amp;rsquo;re requesting too many kittens!</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/access/</guid>
      <description>Javascript Thoughts Why JavaScript I use JavaScript to develop products because it seems faster and easier. Use web browsers as JVM, use DOM to build UI, and sue JS to implement business logic.
React React provides a different way of organize frontend codes. And I like it very much.
Before writing WebApp, my programming practice uses Cpp mostly. So class and components are very handy, and very easy to understand.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/develop-environment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/develop-environment/</guid>
      <description>JS Development Environment 随着前端和 Node.JS 的发展, 以及页面的APP化, JS 成为开发应用的不错的选择. 前后通吃, 语法灵活, 发展迅速, 对提高开发效率很有帮助.
JS 开发发展迅速带来的一个问题是工具和库众多, 开发中选择什么工具成了一个问题. 我从两年前真正开始写JS开始尝试了一些工具和库, 试过之后才知道什么更适合自己.
编辑器 单就文本编辑器而言, 当然还是首推 Emacs 和 Vim. 除这两者之外, 还有许多不错和编辑器和IDE.
 Sublime 比较灵活, 有插件, 可配置. 上手容易, 但要用上各种插件有点繁. Atom 比较适合前端技术栈, github 出品, 应该不错. 没真正用过. Brackets 使用时感觉很方便, web 预览功能很不错. 当时版本较早, 有一些bug, 现在应该更好用了. WebStorm 完整的 IDE 的样子, 对 JS 开发非常不错, 前端, Node.JS, git 都支持, 也有 emacs 模式. 用习惯之后对生产效率应该会有提升.  打包 打包包括了开发上线所需的预编译, 压缩, 转换, 优化, 构建任务.
现在使用的是 Webpack.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/es2015/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/es2015/</guid>
      <description>Core Features of ES2015 (ES6) Note on Adrain Mejia&amp;rsquo;s article
History ES6, a.k.a. ES2015+, ECMAScript6.
Javascript is evolving since it was created, and ES6 is now well supported in all modern browsers.
(compatibility ref)
ES6 core features block-scoped variables We know that var is not block-scoped, but function scoped. In ES6, let and const is used instead of var to limit variable scoped to block. let is the better var A variable must be defined before use when it&amp;rsquo;s defined by let, and it exists only inside its block, like a for-loop or if-block.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/expressjs_note/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/expressjs_note/</guid>
      <description>Note on Express Basic Routing A route method is derived from one of the HTTP methods, and is attached to an instance of the express class.
Route methods Express supports the following routing methods that correspond to HTTP methods: get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, and connect.
To route methods that translate to invalid JavaScript variable names, use the bracket notation.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/nodejs-mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/nodejs-mysql/</guid>
      <description>MySQL in NodeJS 1. 建立数据库连接 createConnection(Object) 该方法接受一个对象作为参数，该对象有四个常用的属性host，user，password，database。与php中链接数据库的参数相同。属性列表如下：
host: 连接数据库所在的主机名. (默认: localhost) port: 连接端口. (默认: 3306) localAddress: 用于TCP连接的IP地址. (可选) socketPath: 链接到unix域的路径。在使用host和port时该参数会被忽略. user: MySQL用户的用户名. password: MySQL用户的密码. database: 链接到的数据库名称 (可选). charset: 连接的字符集. (默认: &amp;#39;UTF8_GENERAL_CI&amp;#39;.设置该值要使用大写!) timezone: 储存本地时间的时区. (默认: &amp;#39;local&amp;#39;) stringifyObjects: 是否序列化对象. See issue #501. (默认: &amp;#39;false&amp;#39;) insecureAuth: 是否允许旧的身份验证方法连接到数据库实例. (默认: false) typeCast: 确定是否讲column值转换为本地JavaScript类型列值. (默认: true) queryFormat: 自定义的查询语句格式化函数. supportBigNumbers: 数据库处理大数字(长整型和含小数),时应该启用 (默认: false). bigNumberStrings: 启用 supportBigNumbers和bigNumberStrings 并强制这些数字以字符串的方式返回(默认: false). dateStrings: 强制日期类型(TIMESTAMP, DATETIME, DATE)以字符串返回，而不是一javascript Date对象返回. (默认: false) debug: 是否开启调试.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/oop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/oop/</guid>
      <description>Object-Oriented Programming of Javascript notes of 1 2 3
JS 的对象 JS 本身是基于对象的语言，在 JS 中所操作的基本都是对象。但在 ES2015 之前它又没有 class 的类。
 对象实例  let record = { name: &amp;#39;&amp;#39;, nation: &amp;#39;&amp;#39; };  Schema 规格
let record1 = { name: &amp;#39;Alpha&amp;#39;, nation: &amp;#39;China&amp;#39; }; let record2 = { name: &amp;#39;Beta, nation: &amp;#39;Denmark&amp;#39; };  给对象赋予属性和方法</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/performance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/performance/</guid>
      <description>Practice of JavaScript Performance Since JavaScript becomes a fullstack programming language, in certain cases the performance of JS is critical. Here are some practice of JS, with some understanding of JS implementation.
Data Store How a variable is create will effect its performance. - Use {} instead of new Object, use [] instead of new Array, use plain string instead of an object. - Use local temporary variable to store variable deep upon the data-chain, and values require many calculation.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/webpack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/webpack/</guid>
      <description>An Introduction to Webpack Webpack is a bundler for javascript, and related resources. All resources are treated as modules, and with various loaders, webpack can handle modules of CommonJs, AMD, ES6, CSS, Image, JSON, Coffeescript, LESS, etc.
// what a webpack config file &#39;webpack.config.js&#39; looks like module: { loaders: [ { test: /\.css$/, loader: &#39;style!css&#39; }, // use ! to chain loaders { test: /\.js$/, loader: &#39;jsx?harmony!babel&#39;, exclude: /node_modules/ } // loaders can be written like &#39;jsx-loader&#39; or &#39;jsx&#39; // loaders can take parameters as a querystring ] }  Entrance and output.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/z-webpack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/z-webpack/</guid>
      <description>Another Webpack Note  其实Webpack的入门指导文章非常多，配置方式也各有各样，这里我推荐题叶大神的入门级指南–Webpack 入门指迷，如果不知道Webpack是什么或者不是很清楚各项配置含义的开发者，可以看此文章扫扫盲。毕竟我这篇文章并不是特别基础。 
1. base.js var path = require(&amp;lsquo;path&amp;rsquo;) var baseConfig = { resolve: { extensions: [&amp;ldquo;, &amp;lsquo;.js&amp;rsquo;], fallback: [path.join(dirname, &amp;lsquo;../node_modules&amp;rsquo;)], alias: { &amp;lsquo;src&amp;rsquo;: path.resolve(dirname, &amp;lsquo;../src&amp;rsquo;), &amp;lsquo;assets&amp;rsquo;: path.resolve(dirname, &amp;lsquo;../src/assets&amp;rsquo;), &amp;lsquo;components&amp;rsquo;: path.resolve(dirname, &amp;lsquo;../src/components&amp;rsquo;) } }, module: { loaders: [{ test: /.js$/, loader: &amp;lsquo;babel&amp;rsquo;, exclude: /node_modules/ }, { test: /.(png|jpe?g|gif|svg|woff2?|eot|ttf|otf)(\?.*)?$/, loader: &amp;lsquo;url?limit=8192&amp;amp;context=client&amp;amp;name=[path][name].[hash:7].[ext]&amp;rsquo; }, { test: /.css$/, loader: &amp;lsquo;style!css!autoprefixer&amp;rsquo;, }, { test: /.scss$/, loader: &amp;lsquo;style!css!autoprefixer!sass&amp;rsquo; }] } };</description>
    </item>
    
    <item>
      <title>Tools</title>
      <link>./tools/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./tools/access/</guid>
      <description> Tools </description>
    </item>
    
    <item>
      <title>Tools</title>
      <link>./tools/makefile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./tools/makefile/</guid>
      <description>Makefile Make Basic make is designed to manage the compiling process based on dependencies. The other functions of make is designed to make it easier to write Makefile.
When we deal with a complex project, there might be lots of source files, header files, lib files, target files. The files have a certain dependency relationship.
$ gcc -c -o test.o test.c $ gcc -o helloworld test.o  The dependency line is: test.</description>
    </item>
    
    <item>
      <title>Index</title>
      <link>./python/</link>
      <pubDate>Sat, 22 Jul 2017 11:51:17 +0800</pubDate>
      
      <guid>./python/</guid>
      <description>Python Class 自带函数 class Foor(object): def __init__(self, *args, **kwargs): print(&amp;#39;init&amp;#39;) super(Bar, self).__init__(*args, **kwargs) def __new__(cls, *args, **kwargs): print(&amp;#39;new&amp;#39;) return super(Bar, cls).__new__(cls, *args, **kwargs) def __call__(self, *args, **kwargs): print(&amp;#39;call&amp;#39;) foo = Bar() foo() # Result: new init call   __init__(self, *args, **kwargs)
在对象创建完成后调用，对当前对象实例进行初始化，无返回值。
 __new__(cls, *args, **kwargs)
创建对象时调用，返回当前对象的一个实例。
 __call__(self, *args, **kwargs)
重载括号运算符。类实现了call方法，则其对象可当作函数使用。
  用自带函数实现单例 class MySingleton(object): def __new__(cls, *args, **kwargs): if not &amp;#39;_instance&amp;#39; in vars(cls): cls._instance = super(MySingleton, cls).</description>
    </item>
    
    <item>
      <title>Index</title>
      <link>./network/</link>
      <pubDate>Fri, 21 Jul 2017 23:10:37 +0800</pubDate>
      
      <guid>./network/</guid>
      <description> Network header 2 inline code
int main(){return 0;}  some code in python
def foo(): pass  </description>
    </item>
    
    <item>
      <title>Layers</title>
      <link>./network/layers/</link>
      <pubDate>Thu, 20 Jul 2017 11:16:50 +0800</pubDate>
      
      <guid>./network/layers/</guid>
      <description></description>
    </item>
    
    <item>
      <title>About</title>
      <link>./about/</link>
      <pubDate>Thu, 20 Jul 2017 09:50:48 +0800</pubDate>
      
      <guid>./about/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>