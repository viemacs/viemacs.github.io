<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Viemacs Notes</title>
    <link>./</link>
    <description>Recent content on Viemacs Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 22 Jul 2017 11:51:17 +0800</lastBuildDate>
    
	<atom:link href="./index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>AI</title>
      <link>./access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./access/</guid>
      <description> An Introduction We trust you have received the usual lecture from the local System Administrator. It usually boils down to these three things:
 1) Respect the privacy of others. 2) Think before you type. 3) With great power comes great responsibility.  </description>
    </item>
    
    <item>
      <title>Agile</title>
      <link>./agile/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./agile/access/</guid>
      <description> Agile </description>
    </item>
    
    <item>
      <title>Agile</title>
      <link>./agile/scrum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./agile/scrum/</guid>
      <description> Scrum </description>
    </item>
    
    <item>
      <title>Agile</title>
      <link>./agile/software-development/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./agile/software-development/</guid>
      <description>Software Development 软件开发中要考虑的工程因素有进度, 成本, 质量, 维护 等等. 而现在软件开发中要面对需求变更, 不定需求, 无用户需求. 为解决这些问题, 软件行业在以下几个方面做出了成功的尝试: 流程工具, 设计, 测试, 人力.
对于团队, 要做人员备份和 周期轮换.
历史 产品实现的开发管理中需求, 设计, 实现, 验证, 维护所需要投入比成为了 7:6:7:13:67, 使软件开发难以为继.
 NATO 在 1968 年提出的软件工程的概念, 强调软件开发的 系统化, 规范化, 数量化. Royce 在 1960 年提出了瀑布模型, 按照工程的方式为软件开发划分了阶段. 阶段划分使软件开发进度有所依循, 有 deadline/milestone 来跟踪阶段. 但瀑布模型的阶段间缺少反馈, 开发的结果在后期才可以清楚得看到, 问题的追溯与修正代价太大, 使得它不适应需求的变化. 现在的做法是在每个迭代中应用瀑布模型.   开发中目前的问题有需求和市场两方面. 需求通常是不确定的, 会不断变动的, 在开发初期无法掌握细节, 容易造成过度设计, 过度开发. 市场中则充满(同质)竞争, 市场的快速变化带来需求的快速变化, 需要开发过程能够快速响应.
需求的不明确和频繁变化 -&amp;gt; 功能变更 -&amp;gt; 交付时间短 -&amp;gt; 测试不充分 -&amp;gt; 交付质量差 -&amp;gt; 修改成本 需求的不明确和频繁变化 -&amp;gt; 功能变更 -&amp;gt; 设计修改 -&amp;gt; 设计质量低 -&amp;gt; 修改成本 | 变更</description>
    </item>
    
    <item>
      <title>Agile</title>
      <link>./agile/tdd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./agile/tdd/</guid>
      <description> Test Driven Development </description>
    </item>
    
    <item>
      <title>Agile</title>
      <link>./agile/xp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./agile/xp/</guid>
      <description> XP, eXtreme Programming </description>
    </item>
    
    <item>
      <title>Algorithm</title>
      <link>./algorithm/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./algorithm/access/</guid>
      <description> Algorithm </description>
    </item>
    
    <item>
      <title>Algorithm</title>
      <link>./algorithm/huffman/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./algorithm/huffman/</guid>
      <description>Huffman Encoding class Node(object): def __init__(self, symbol = &amp;#39;&amp;#39;, weight = 0, left = None, right = None): self.symbol, self.weight, self.left, self.right = symbol, weight, left, right if (left and right): self.weight = left.weight + right.weight def result(self, code = &amp;#39;&amp;#39;): r = [] self.symbol and r.append((self.symbol, self.weight, code)) self.left and r.extend(self.left.result(code + &amp;#39;0&amp;#39;)) self.right and r.extend(self.right.result(code + &amp;#39;1&amp;#39;)) return r def genHuffman(char, freq): nodeList = [] for i in range(len(char)): nodeList.</description>
    </item>
    
    <item>
      <title>C</title>
      <link>./c/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./c/access/</guid>
      <description> C </description>
    </item>
    
    <item>
      <title>C</title>
      <link>./c/memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./c/memory/</guid>
      <description>Memory #include &amp;lt;string.h&amp;gt; int g_a = 0; // global, initialized int* g_p; // global, uninitialized int main() { int a; // stack char s[] = &amp;quot;ab&amp;quot;; // s: stack, &amp;quot;ab&amp;quot; constant char *p1; // static char *p2 = &amp;quot;12&amp;quot;; // p2: stack, &amp;quot;12&amp;quot; constant static int b = 0;// static g_p = (char *)malloc(8); // heap p1 = (char *)malloc(8); // heap strcpy(g_p, &amp;quot;12&amp;quot;); // &amp;quot;12&amp;quot; constant // the memory might be optimized by compiler and use the same memory as p2 return 0; }  内存分配方式中的 栈、堆-自由存储区、全局与静态存储区、常量存储区  栈</description>
    </item>
    
    <item>
      <title>Design</title>
      <link>./design/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./design/access/</guid>
      <description> Design </description>
    </item>
    
    <item>
      <title>Design</title>
      <link>./design/design-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./design/design-pattern/</guid>
      <description> Design Pattern 设计模式是经过验证的代码设计经验的总结。其关注点是代码的可重用、易理解、可靠性。
设计模式的基本类型有：创建、结构、行为。
设计原则 设计模式是设计原则的实现，以达到代码的复用和可维护。
 单一职责原则 Single Responsibility Principle
 开闭原则 Open Closed Principle
Software entities should be open for extension, but closed for modification. 模块应对扩展开放，对修改关闭。
 里氏代换原则 Liskov Substitution Principle
子类可代替父类运行。这种代换是继承利用的基础。
 依赖倒转原则 Dependency Inversion Principle
子类代替父类后，程序的行为不变化。这是面向对象设计的标志。
 接口隔离原则 Interface Segregation Principle
各接口间互不影响。每个接口可以做而且仅做自己需要做和应该做的事。不是所有可以做的事都应放到一个接口中。
 合成聚合复用原则 Composite/Aggregate Reuse Principle
应优先使用合成与聚合，而不是继承。合成复用原则是在新对象中使用已有对象，新对象通过向已有对象委派来复用已有功能。使各个类之间的联系尽量少，才好提高扩展性和可维护性。
 迪米特最小知识原则 Principle of Least Knowledge
各个对象对其他对象的了解应尽可能少。
  在解决问题时，设计模式可以帮忙我们在更高的抽象层次上工作。先是对问题的分析，了解问题中的因果关系，看使用模式的先决条件是否满足。然后根据分析给出解决方案。解决方案不是具体的设计和实现，而是对问题做抽象描述，表明如何用元素的组合而解决问题。
创建  单例模式 Singleton 下一个类仅有一个实例和一个全局访问点。要注意单例模式在使用多线程、序列化、类装载器（multi-threading, serialization, class loaders）时的问题。 适用条件: 类只能有一个实例，可以从全局访问；实例可通过子类扩展。 工厂模式 Factory Method 定义一个用于创建对象的接口，由子类确定实例化哪个对象，使类的实例化延后到子类。 适用条件: 一个类希望/需要由其子类来创建对象。 抽象工厂模式 Abstract Factory 不指定具体的类，仅提供一个创建一组相关/相依赖对象的接口。 适用条件: 只提供接口而不是实现。联合使用一系列的对象。 建造者模式 Builder 将（复杂）对象的构建和表示分离，使同样的构建过程可以创建不同的表示。 适用条件: 对象创建的算法应独立于对象，或对不同的对象有不同的表示。 原型模式 Prototype 用原型的实例来指定所创建对象的种类，并通过复制这个原型来创建新的对象。 适用条件: 在运行时才指定实例化的类，如动态装载；类的实例只会是几个不同状态组合中的一种时。  结构  适配器模式 Adapter 将一个类的接口转换成另一个接口，使接口不兼容的类可以一起工作。 适用条件: 使用已存在的类，但接口不合要求；新建可复用的类，与不相关或不可预见的类兼容。 桥接模式 Bridge 将类的抽象部分和实现部分分离，分别独立改变。 适用条件: 装饰模式 Decorator 向对象动态增加额外职责。比生成子类更灵活地扩展一个类的功能。 适用条件: 组合模式 Composite 将对象组合成表达整体与部分关系的树形层次结构，使单个对象和复合对象在使用上一致。 适用条件: 外观模式 Facade 为子系统的一组接口提供一致的界面，定义高层接口，增加子系统的易用性。 适用条件: 享元模式 Flyweight 用共享技术有效支持大量细粒度的对象。 适用条件: 代理模式 Proxy 为其他对象提供代理，用代理来控制对象的访问。 适用条件:  行为  模版模式 Template Method 定义方法中的算法骨架，将部分步骤延后到子类中，使子类不改变算法结构而重定义算法中的某些步骤。 适用条件: 命令模式 Command 将请求封装为对象，？？使用不同请求来对接收者进行参数化？？，可将请求排队、取消、记录日志。 适用条件: 迭代器模式 适用条件: 观察者模式 Observer 在对象间建立一对多的依赖关系，当一个对象改变时，所有依赖于它的对象都自动刷新。 适用条件: 中介者模式 Mediator 封装一系列的对象交互，使各对象不需要显示相互引用，松耦合，并可以独立改变对象间的交互。 适用条件: 备忘录模式 Memento 不破坏对象的封装，捕获对象内部的状态并在对象外部保存，这可将对象恢复到保存时的状态。 适用条件: 解释器模式 Interpreter 定义一个给定语言的文法表示和解释器，来表示解释此语言的语句。 适用条件: 状态模式 State 允许对象在内部状态改变时改变行为，像是对象所属的类发生了变化。 适用条件: 策略模式 Strategy 定义并封装一系列的算法，并使它们可相互替换，使算法变化独立于使用者。 适用条件: 责任链模式 Chain of Responsibility 解耦请求的发送者和接收者。将多个可能处理请求的对象连成一条链，请 适用条件: 求在链上传递，直到有一个对象处理它。 访问者模式 Visitor 表示对一个对象中元素的操作，可以定义作用于元素的新操作而不改变元素的类。 适用条件:  </description>
    </item>
    
    <item>
      <title>Design</title>
      <link>./design/reactive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./design/reactive/</guid>
      <description>Reactive System 响应式系统，响应式编程 事件驱动实现响应式编程，消息驱动实现响应式系统。
响应式编程强调的是数据流而非控制流。
例子：
 Futures / Promises：值的容器，many-read and single-write 响应式 流：无限制的数据处理流，支持异步，非阻塞，多个源与目的 反压转换管道 Back-pressure transformation pipelines 数据流变量：依赖于输入，过程procedures 或其他单元的 单赋值变量（存储单元）single assignment variables，能够自动更新值的改变。如：表格软件中一个单元格值的改变会影响到所有依赖于它的函数，顺流而下地使它们产生新的值。   JVM 中支持 非阻塞式反压异步流，响应式编程 的流行库有：Akka Streams, Ratpack, Reactor, ExJava, Vert.x
响应式编程的基本好处是：提高多核和多 CPU 硬件的计算资源利用率；通过减少序列化点来提高性能（阿姆达尔定律，古瑟通用可伸缩定律 Amdahl, Guenther）。
响应式编程中，active 活动组件间一般不需要明确的协作，而避开了传统的编程范式的做法：尽力提供一个简单直接的可持续的方法来处理异步非阻塞计算和 I/O。
响应式编程的价值在于组件的创建和工作流的组合。在异步执行上加入反压以避免过度使用/无限度地消耗资源。
为在更高层次上理清一个系统，设计响应式系统，需要为其设计响应式架构。响应式编程仅是一种编程范式，要注意它的适用条件和情形。
 事件驱动与消息驱动
响应式编程的着眼点在短时数据流链条上的计算，因而使用事件驱动；响应式系统关注于通过分布式系统的通信和协作所得到的弹性和韧性，使用消息驱动 messaging。
事件驱动的数据流驱动模型，拥有 long-live addressable 长期存活可寻址 组件的消息驱动系统，两者的不同在于，消息具有固定的导向，事件没有；消息会有一个明确的去向，而事件只是一个等待被观察的信息。消息式结构更适用于异步，因为消息的发送与接收和发送者与接收者是分离的。
 一条消息就是一则被送往一个明确目的地的数据。一个事件则是达到某个给定状态的组件发出的一个信号。在一个消息驱动的系统中，可寻址到的接收者等待消息的到来然后响应它，否则保持休眠状态。在一个事件驱动系统中，通知的监听者被绑定到消息源上，这样当消息被发出时它就会被调用。这意味着一个事件驱动系统专注于可寻址的事件源，而消息驱动系统专注于可寻址的接收者。
 分布式系统需要通过消息在网络上传输进行交流，以实现其沟通基础，而事件的发出则是本地的。常见的做法是在底层通过发送包裹着事件的消息来搭建跨网络的事件驱动系统，这样能维持在分布式环境下事件驱动编程模型的相对简易，可以用在合理范围内的特殊案例上。
分布式环境下的事件驱动在编程模型的抽象性和简易性上有好处，但在控制性上有欠缺。消息强迫我们去拥抱分布式系统的真实性和一致性。你需要去考虑局部错误，错误侦测，丢弃/复制/重排序消息 （partial failures, failure detection, dropped/duplicated/reordered），还有一致性问题，管理多个并发真实性（并发真实性？）。你需要面对它们，处理它们，而不是藏在低劣的抽象层后，假装网络并不存在，像是 EJB, RPC, CORBA, XA。
在设计中，这种语义和适用性上的不同对应用有深刻的影响，包括分布式系统的复杂性中的弹性，韧性，移动性，位置透明和管理。
在使用了响应式编程技术的响应式系统中，有用于沟通的消息，也不呈现现实的事件。</description>
    </item>
    
    <item>
      <title>Dist</title>
      <link>./dist/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./dist/access/</guid>
      <description> Dist </description>
    </item>
    
    <item>
      <title>Dist</title>
      <link>./dist/kafka/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./dist/kafka/</guid>
      <description> Kafka </description>
    </item>
    
    <item>
      <title>ESC</title>
      <link>./ecs/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./ecs/access/</guid>
      <description> Elastic Compute </description>
    </item>
    
    <item>
      <title>Editor</title>
      <link>./editor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./editor/</guid>
      <description>Editor Emacs Emacs Config File init.el</description>
    </item>
    
    <item>
      <title>Editor</title>
      <link>./editor/vim_shortcuts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./editor/vim_shortcuts/</guid>
      <description>VIM Shortcuts 退出  w filename: 保存正在编辑的文件filename wq filename: 保存后退出正在编辑的文件filename q：退出不保存。  窗口操作  ctrl+w p: 在两个分割窗口之间来回切换。 ctrl+w j: 跳到下面的分割窗 ctrl+w h: 跳到左边的分割窗。 ctrl+w k: 跳到上面的分割窗。 ctrl+w l: 跳到右边的分割窗。  移动 h,j,k,l: 左，下，上，右。 w: 下一个词的词首。 e:下一个词的词尾。 b:上一个词的词首。 &amp;lt;&amp;gt;: v 模式选中后进行缩进。  跳转 %: 可以匹配{},&amp;quot;&amp;quot;,(),[]之间跳转。 H、M、L：直接跳转到当前屏幕的顶部、中部、底部。 #H：跳转到当前屏的第#行。 #L：跳转到当前屏的倒数第#行。 zt: 当前编辑行置为屏顶。 zz: 当前编辑行置为屏中。 zb: 当前编辑行置为屏底。 G：直接跳转到文件的底部。 gg: 跳转到文件首。 ():跳转到当前的行首、行尾。 {}：向上、向下跳转到最近的空行。 [{：跳转到目前区块开头。 ]}：跳转到目前区块结尾。 0: 跳转到行首。 $: 跳转到行尾。 2$: 跳转到下一行的行尾。 #：跳转到该行的第#个位置。 #G: 15G,跳转到15行。 :#：跳转到#行。 f&#39;n&#39;：跳转到下一个&amp;quot;n&amp;quot;字母后。 ctrl+b: 向后翻一页。 ctrl+f：向前翻一页。 ctrl+u: 向后翻半页。 ctrl+d: 向前翻半页。 ctry+e: 下滚一行。  选择 1.</description>
    </item>
    
    <item>
      <title>Errors</title>
      <link>./errors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./errors/</guid>
      <description>Errors This error section is stored in a separate file, errors.md. DocuAPI allows you to split the single page documentation in as many files as needed. Files are included in the default Hugo page order . One way of ordering the pages is by setting the page `weight` in the front matter. Pages with lower weight will be listed first. The Kittn API uses the following error codes:
   Error Code Meaning     400 Bad Request &amp;ndash; Your request sucks   401 Unauthorized &amp;ndash; Your API key is wrong   403 Forbidden &amp;ndash; The kitten requested is hidden for administrators only   404 Not Found &amp;ndash; The specified kitten could not be found   405 Method Not Allowed &amp;ndash; You tried to access a kitten with an invalid method   406 Not Acceptable &amp;ndash; You requested a format that isn&amp;rsquo;t json   410 Gone &amp;ndash; The kitten requested has been removed from our servers   418 I&amp;rsquo;m a teapot   429 Too Many Requests &amp;ndash; You&amp;rsquo;re requesting too many kittens!</description>
    </item>
    
    <item>
      <title>Golang</title>
      <link>./go/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./go/access/</guid>
      <description>Golang The Design Go 看上去是 C 而不是 C++。我自己在学习和项目使用时，并没有很在意 C 和 C++ 的区别，但看到 Go 时，发现了许多不同。
package foobar type Bar struct { n int } func (b *Bar) foo() int { return b.n }  Go 语言在设计中的感觉是追求显式表达，避免隐式表达。
class Bar(object): n = &amp;quot;a local variable&amp;quot; def __init__(self): self.n = 0 def foo(self): pass  Python 中也有相似的地方，在类中显式地写出self，对self的操作才是对对象的操作。
但 Go 中向对象增加方法method也要显式地写出对象。
Go 中不支持参数默认值，函数重载。C 也不支持，是 C++ 支持。
参数默认值其实是一种隐式表达。调用者仅看名字，不去查看默认参数时，有时会遇到参数默认值导致问题，给调试带来不少麻烦。
一个表达的意义应该是唯一的，没有二义性。凡是可能导致二义性的行为都应是禁止或尽量避免的。比如函数默认参数，比如类的默认拷贝构造函数。还有一个书写方便但让项目更难调试的功能：自动类型转换。
进一步，一种表达的写法也应尽可能是唯一的。在 Go 语言的写法中，就没有单行 if 语句要不要加括号/braces 这样的问题。if else 中 else 的位置也是固定的。另一方面，你可以用无条件的 switch 来更清楚地表达 if-then-else。</description>
    </item>
    
    <item>
      <title>Golang</title>
      <link>./go/oo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./go/oo/</guid>
      <description>Object Orientation Golang 中没有 class。它的面向对象的实现，可以用 struct 来做。
type Record struct { Title string Dept string value int }  Golang 中变量和函数首字母大写相当于 public， 小写相当于 private，在包和结构体中都是如此。
func (r Record) Publish() { fmt.Println(r.Title) } func (r *Record) setTitle(s string) { r.Title = s }  Golang 中结构体的方法声明与众不同，是普通函数的方式，并在 func 后加上函数操作的对象，对象加 * 则传指针，不加时传值。
record := &amp;amp;Record{} record.Title = &amp;quot;New Time&amp;quot; record2 := &amp;amp;Record{Title: &amp;quot;Two&amp;quot;} record3 := new(Record) record3.Title = &amp;quot;Three&amp;quot; record4 := Record{} record4.Title = &amp;quot;Four&amp;quot; record5 := Record{Title: &amp;quot;Five&amp;quot;}  对象实例化。加 &amp;amp; 和 new 时，生成指针对象。一般当对象较小时，传值较好；对象较大时，传指针较好。</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/access/</guid>
      <description>Javascript Thoughts Why JavaScript I use JavaScript to develop products because it seems faster and easier. Use web browsers as JVM, use DOM to build UI, and sue JS to implement business logic.
React React provides a different way of organize frontend codes. And I like it very much.
Before writing WebApp, my programming practice uses Cpp mostly. So class and components are very handy, and very easy to understand.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/develop-environment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/develop-environment/</guid>
      <description>JS Development Environment 随着前端和 Node.JS 的发展, 以及页面的APP化, JS 成为开发应用的不错的选择. 前后通吃, 语法灵活, 发展迅速, 对提高开发效率很有帮助.
JS 开发发展迅速带来的一个问题是工具和库众多, 开发中选择什么工具成了一个问题. 我从两年前真正开始写JS开始尝试了一些工具和库, 试过之后才知道什么更适合自己.
编辑器 单就文本编辑器而言, 当然还是首推 Emacs 和 Vim. 除这两者之外, 还有许多不错和编辑器和IDE.
 Sublime 比较灵活, 有插件, 可配置. 上手容易, 但要用上各种插件有点繁. Atom 比较适合前端技术栈, github 出品, 应该不错. 没真正用过. Brackets 使用时感觉很方便, web 预览功能很不错. 当时版本较早, 有一些bug, 现在应该更好用了. WebStorm 完整的 IDE 的样子, 对 JS 开发非常不错, 前端, Node.JS, git 都支持, 也有 emacs 模式. 用习惯之后对生产效率应该会有提升.  打包 打包包括了开发上线所需的预编译, 压缩, 转换, 优化, 构建任务.
现在使用的是 Webpack.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/es2015/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/es2015/</guid>
      <description>Core Features of ES2015 (ES6) Note on Adrain Mejia&amp;rsquo;s article
History ES6, a.k.a. ES2015+, ECMAScript6.
Javascript is evolving since it was created, and ES6 is now well supported in all modern browsers.
(compatibility ref)
ES6 core features block-scoped variables We know that var is not block-scoped, but function scoped. In ES6, let and const is used instead of var to limit variable scoped to block. let is the better var A variable must be defined before use when it&amp;rsquo;s defined by let, and it exists only inside its block, like a for-loop or if-block.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/expressjs_note/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/expressjs_note/</guid>
      <description>Note on Express Basic Routing A route method is derived from one of the HTTP methods, and is attached to an instance of the express class.
Route methods Express supports the following routing methods that correspond to HTTP methods: get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, and connect.
To route methods that translate to invalid JavaScript variable names, use the bracket notation.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/nodejs-mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/nodejs-mysql/</guid>
      <description>MySQL in NodeJS 1. 建立数据库连接 createConnection(Object) 该方法接受一个对象作为参数，该对象有四个常用的属性host，user，password，database。与php中链接数据库的参数相同。属性列表如下：
host: 连接数据库所在的主机名. (默认: localhost) port: 连接端口. (默认: 3306) localAddress: 用于TCP连接的IP地址. (可选) socketPath: 链接到unix域的路径。在使用host和port时该参数会被忽略. user: MySQL用户的用户名. password: MySQL用户的密码. database: 链接到的数据库名称 (可选). charset: 连接的字符集. (默认: &amp;#39;UTF8_GENERAL_CI&amp;#39;.设置该值要使用大写!) timezone: 储存本地时间的时区. (默认: &amp;#39;local&amp;#39;) stringifyObjects: 是否序列化对象. See issue #501. (默认: &amp;#39;false&amp;#39;) insecureAuth: 是否允许旧的身份验证方法连接到数据库实例. (默认: false) typeCast: 确定是否讲column值转换为本地JavaScript类型列值. (默认: true) queryFormat: 自定义的查询语句格式化函数. supportBigNumbers: 数据库处理大数字(长整型和含小数),时应该启用 (默认: false). bigNumberStrings: 启用 supportBigNumbers和bigNumberStrings 并强制这些数字以字符串的方式返回(默认: false). dateStrings: 强制日期类型(TIMESTAMP, DATETIME, DATE)以字符串返回，而不是一javascript Date对象返回. (默认: false) debug: 是否开启调试.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/oop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/oop/</guid>
      <description>Object-Oriented Programming of Javascript notes of 1 2 3
JS 的对象 JS 本身是基于对象的语言，在 JS 中所操作的基本都是对象。但在 ES2015 之前它又没有 class 的类。
如果要从原型对象生成实例对象，要把属性和方法封装到对象里。properties and methods
 对象实例  let record = { name: &amp;quot;&amp;quot;, nation: &amp;quot;&amp;quot; };  Schema 规格
let record1 = { name: &amp;quot;Alpha&amp;quot;, nation: &amp;quot;China&amp;quot; }; let record2 = { name: &amp;quot;Beta, nation: &amp;quot;Denmark&amp;quot; };  给对象赋予属性和方法
这可以看作最简单的封装，但原型和实例间并不存在内在联系。
function Record(name, nation) { return { name: name, nation: nation, }; } let record1 = Record(&amp;quot;Alpha&amp;quot;, &amp;quot;China&amp;quot;); let record2 = Record(&amp;quot;Beta&amp;quot;, &amp;quot;Denmark&amp;quot;);  用函数调用返回对象方式可以在原型和实例间建立一定联系，但两个实例间没有内在联系。</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/performance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/performance/</guid>
      <description>Practice of JavaScript Performance Since JavaScript becomes a fullstack programming language, in certain cases the performance of JS is critical. Here are some practice of JS, with some understanding of JS implementation.
Data Store How a variable is create will effect its performance. - Use {} instead of new Object, use [] instead of new Array, use plain string instead of an object. - Use local temporary variable to store variable deep upon the data-chain, and values require many calculation.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/webpack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/webpack/</guid>
      <description>An Introduction to Webpack Webpack is a bundler for javascript, and related resources. All resources are treated as modules, and with various loaders, webpack can handle modules of CommonJs, AMD, ES6, CSS, Image, JSON, Coffeescript, LESS, etc.
// what a webpack config file &#39;webpack.config.js&#39; looks like module: { loaders: [ { test: /\.css$/, loader: &#39;style!css&#39; }, // use ! to chain loaders { test: /\.js$/, loader: &#39;jsx?harmony!babel&#39;, exclude: /node_modules/ } // loaders can be written like &#39;jsx-loader&#39; or &#39;jsx&#39; // loaders can take parameters as a querystring ] }  Entrance and output.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/z-webpack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/z-webpack/</guid>
      <description>Another Webpack Note  其实Webpack的入门指导文章非常多，配置方式也各有各样，这里我推荐题叶大神的入门级指南–Webpack 入门指迷，如果不知道Webpack是什么或者不是很清楚各项配置含义的开发者，可以看此文章扫扫盲。毕竟我这篇文章并不是特别基础。 
1. base.js var path = require(&amp;lsquo;path&amp;rsquo;) var baseConfig = { resolve: { extensions: [&amp;ldquo;, &amp;lsquo;.js&amp;rsquo;], fallback: [path.join(dirname, &amp;lsquo;../node_modules&amp;rsquo;)], alias: { &amp;lsquo;src&amp;rsquo;: path.resolve(dirname, &amp;lsquo;../src&amp;rsquo;), &amp;lsquo;assets&amp;rsquo;: path.resolve(dirname, &amp;lsquo;../src/assets&amp;rsquo;), &amp;lsquo;components&amp;rsquo;: path.resolve(dirname, &amp;lsquo;../src/components&amp;rsquo;) } }, module: { loaders: [{ test: /.js$/, loader: &amp;lsquo;babel&amp;rsquo;, exclude: /node_modules/ }, { test: /.(png|jpe?g|gif|svg|woff2?|eot|ttf|otf)(\?.*)?$/, loader: &amp;lsquo;url?limit=8192&amp;amp;context=client&amp;amp;name=[path][name].[hash:7].[ext]&amp;rsquo; }, { test: /.css$/, loader: &amp;lsquo;style!css!autoprefixer&amp;rsquo;, }, { test: /.scss$/, loader: &amp;lsquo;style!css!autoprefixer!sass&amp;rsquo; }] } };</description>
    </item>
    
    <item>
      <title>Network</title>
      <link>./network/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./network/access/</guid>
      <description> Network </description>
    </item>
    
    <item>
      <title>Network</title>
      <link>./network/cloud/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./network/cloud/</guid>
      <description>Cloud 云计算，是用互联网来接入存储或者运行在远程服务器端的应用，数据，服务。所以云计算行业包括了使用基于互联网的方法来计算，存储和开发的公司，或说是在互联网上提供其服务的公司。
IaaS, PasS, SaaS 云计算可以分为不同层次：基础设施-平台-软件，即 Infrastructure as a Service, Platform as a Service, Software as a Service。
 IaaS: Infrastructure-as-a-Service 基础设施即服务
提供了远程服务器、存储等网络硬件，使企业在运行应用时不再需要购买服务器等硬件，节省了维护成本和办公场地。实际提供 IaaS 的公司，如 Amozon，MicroSoft，VMWare，Rackspace，RedHat，不仅提供服务器，还会单独提供计算能力。
 Paas: Platform-as-a-Service 平台即服务
PaaS，也可以叫中间件，使企业的所有开发都能够在这里进行，以节省时间和资源。PaaS 提供了各种开发和分发应用的解决方案，如虚拟服务器和操作系统。如网页应用管理、应用设计、应用虚拟主机、存储、安全、应用开发协作工具。
大型 PaaS 提供商有: Google App Engine, Microsoft Azure, Force.com, Heroku, Engine Yard; 以及新兴的 AppFog, Mendix, Standing Cloud.
 SaaS: Software-as-a-Service 软件即服务
通过远程服务器来运行的应用，就属于 SaaS，也是消费者每天接触到的一层云服务。这类服务常由网页接入，商用+家用的如 Netflx, MOG, Google Apps, Box.net, Dropbox, iCloud。商用 SaaS 应用如 GoToMeeting (Citrix), WebEx (Cisco), CRM (Salesforce), ADP, SuccessFactors (Workday)。</description>
    </item>
    
    <item>
      <title>Network</title>
      <link>./network/proxy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./network/proxy/</guid>
      <description> Proxy 正向代理与反向代理区别 正向代理是位于客户端和原始服务器（origin server）之间的服务器。客户端向原始服务器请求内容时，向代理发送一个指定了目标的请求，由代理向原始服务器转发请求，然后将获得的内容返回客户端。客户端需要对发出的请求进行处理，使代理服务器了解请求的目标。
反向代理中，代理过程完全由客户端访问的服务器完成，代理过程对客户端不可见。客户端发出普通请求，反向代理服务器判断应向哪里的原始服务器转发请求，并将返回的内容作为响应转发回客户端。
正向代理中，客户端通过代理服务器隐藏了自身，如果需要安全性，可以在客户端连接代理服务器时进行鉴权。
用途
 正向代理：向在防火墙内的局域网客户端提供外网的访问；使用缓冲可以减少对外网的网络访问。 反向代理：向外网提供防火墙内的服务器访问；为后端多服务器提供负载平衡；为后端低速服务器提供缓冲；在一个URL空间下提供多服务器多页面的内容。  </description>
    </item>
    
    <item>
      <title>Norm</title>
      <link>./norm/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./norm/access/</guid>
      <description> Norm </description>
    </item>
    
    <item>
      <title>Norm</title>
      <link>./norm/code-review/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./norm/code-review/</guid>
      <description>Code Review 为什么做 Code Review 做 Code review 是为了改进代码质量. 通过对代码, 测试过程和注释进行检查, 来确认方案设计和代码实现.
Code review 的主要目的:
 保证代码质量   程序逻辑 需求和设计的实现 查找和排除系统缺陷 可读性 可维护性
 保证项目组人员的良好沟通
 项目或产品的代码更容易维护
   提高参与者开发水平 传递作者的意图和想法，使其他人可以更加熟悉代码，利于维护代码和改进代码 评审过程使大家更多的理解系统，重构思路， 确定作者的设计和实现清晰，简单 帮助初级开发人员学习高级开发人员的经验，达到知识共享, 相互学习，提高开发者水平  次要目的: - 查找程序的bug - 保证代码风格和编码标准 - 编码风格 - 避免开发人员犯一些很常见，很普通的错误 - 在项目早期就能够发现代码中的BUG
消除 Bug 主要靠测试. 由单元测试，功能测试，性能测试，回归测试来消除Bug。 单元测试为主。单元测试最接近bug，bug没有扩散的地方。 在 code review 之前，要有单元测试和单元测试报告，
代码风格和编码标准是确定的, 是靠个人可以做到的, 所以在代码提交时就应该是符合规范的。 代码规范，有作者自己和一些检查代码规范的工具。
规范性 - 注释格式 - 命名规范
 异常处理 日志处理 代码组织结构</description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>./sql/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./sql/access/</guid>
      <description> SQL </description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>./sql/variable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./sql/variable/</guid>
      <description>Declare a Variable in MySQL (ref)
There are mainly three types of variables in MySQL:
User-defined variables (prefixed with @):
You can access any user-defined variable without declaring it or initializing it. If you refer to a variable that has not been initialized, it has a value of NULL and a type of string.
SELECT @var_any_var_name You can initialize a variable using SET or SELECT statement:
SET @start = 1, @finish = 10;</description>
    </item>
    
    <item>
      <title>Tools</title>
      <link>./tools/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./tools/access/</guid>
      <description> Tools </description>
    </item>
    
    <item>
      <title>Tools</title>
      <link>./tools/makefile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./tools/makefile/</guid>
      <description>Makefile Make Basic make is designed to manage the compiling process based on dependencies. The other functions of make is designed to make it easier to write Makefile.
When we deal with a complex project, there might be lots of source files, header files, lib files, target files. The files have a certain dependency relationship.
$ gcc -c -o test.o test.c $ gcc -o helloworld test.o  The dependency line is: test.</description>
    </item>
    
    <item>
      <title>Index</title>
      <link>./python/</link>
      <pubDate>Sat, 22 Jul 2017 11:51:17 +0800</pubDate>
      
      <guid>./python/</guid>
      <description>Python Class 自带函数 class Foor(object): def __init__(self, *args, **kwargs): print(&amp;#39;init&amp;#39;) super(Bar, self).__init__(*args, **kwargs) def __new__(cls, *args, **kwargs): print(&amp;#39;new&amp;#39;) return super(Bar, cls).__new__(cls, *args, **kwargs) def __call__(self, *args, **kwargs): print(&amp;#39;call&amp;#39;) foo = Bar() foo() # Result: new init call   __init__(self, *args, **kwargs)
在对象创建完成后调用，对当前对象实例进行初始化，无返回值。
 __new__(cls, *args, **kwargs)
创建对象时调用，返回当前对象的一个实例。
 __call__(self, *args, **kwargs)
重载括号运算符。类实现了call方法，则其对象可当作函数使用。
  用自带函数实现单例 class MySingleton(object): def __new__(cls, *args, **kwargs): if not &amp;#39;_instance&amp;#39; in vars(cls): cls._instance = super(MySingleton, cls).</description>
    </item>
    
    <item>
      <title>Layers</title>
      <link>./network/layers/</link>
      <pubDate>Thu, 20 Jul 2017 11:16:50 +0800</pubDate>
      
      <guid>./network/layers/</guid>
      <description></description>
    </item>
    
    <item>
      <title>About</title>
      <link>./about/</link>
      <pubDate>Thu, 20 Jul 2017 09:50:48 +0800</pubDate>
      
      <guid>./about/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>./agile/ci/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./agile/ci/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>./agile/gerrit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./agile/gerrit/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>./agile/unittest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./agile/unittest/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>./norm/code_review/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./norm/code_review/</guid>
      <description>review 记录：作者记录，表格记录，checkout -b review， checkout -b review_by_Foo, git pull &amp;amp;&amp;amp; checkout -b review_by_Foo
http://blog.csdn.net/haoel/article/details/4469526
http://blog.csdn.net/haoel/article/details/4469462
http://www.cnblogs.com/lhb25/p/15-best-code-review-tools-for-developers.html
Code Review中的几个提示
Code Review应该是软件工程最最有价值的一个活动，之前，本站发表过《简单实用的Code Review工具》，那些工具主要是用来帮助更有效地进行这个活动，这里的这篇文章，我们主要想和大家分享一下Code Review代码审查的一些心得。
首先，我们先来看看Code Reivew的用处：
Code reviews 中，可以通过大家的建议增进代码的质量。 Code reviews 是一个传递知识的手段，可以让其它并不熟悉代码的人知道作者的意图和想法，从而可以在以后轻松维护代码。 Code reviews 也鼓励程序员们相互学习对方的长处和优点。 Code reviews 也可以被用来确认自己的设计和实现是一个清楚和简单的。 你也许注意到了在上面的Code Reivew中的诸多用处中，我们没有提到可以帮助找到程序的bug和保证代码风格和编码标准。这是因为我们认为：
Code reviews 不应该承担发现代码错误的职责。Code Review主要是审核代码的质量，如可读性，可维护性，以及程序的逻辑和对需求和设计的实现。代码中的bug和错误应该由单元测试，功能测试，性能测试，回归测试来保证的（其中主要是单元测试，因为那是最接近Bug，也是Bug没有扩散的地方）
所以，在今天，请不要把上面的那两件事分散了Code Review的注意力，取而代之的是，对于Bug，程序的作者要在Review前提交自己的单元测试报告（如：XUnit的测试结果），对于代码规范，这是程序作者自己需要保证的，而且，有一些工具是可以帮你来检查代码规范的。
不是说不能在Code Review中报告一个程序的bug或是一个代码规范的问题。只是说那并不是Code Review的意图。
1.- 经常进行Code Review 以前经历过几个相当痛苦的Code Review，那几次Code Review都是在程序完成的时候进行的，当你面对那近万行的代码，以前N我掺和在一起的功能，你会发现，整个Code Review变得非常地艰难，用不了一会儿，你就会发现大家都在拼命地打着哈欠，但还是要坚持，有时候，这样的Review会持续3个小时以上，相当的夸张。而且，会议上会出现相当多的问题和争论，因为，这就好像，人家都把整个房子盖好了，大家Review时这挑一点那挑一点，有时候触动地基或是承重墙体，需要大动手术，让人返工，这当然会让盖房的人一下就跳起来极力地维护自己的代码，最后还伤了团队成员的感情。
所以，千万不要等大厦都盖好了再去Reivew，而且当有了地基，有了框架，有了房顶，有了门窗，有了装修，的各个时候循序渐进地进行Review，这样反而会更有效率，也更有帮助。
下面是一些观点，千万要铭记：
要Review的代码越多，那么要重构，重写的代码就会越多。而越不被程序作者接受的建议也会越多，唾沫口水战也会越多。 程序员代码写得时候越长，程序员就会在代码中加入越来越多的个人的东西。 程序员最大的问题就是“自负”，无论什么时候，什么情况下，有太多的机会会让这种“自负”澎涨开来，并开始影响团队影响整个项目，以至于听不见别人的建议，从而让Code Review变成了口水战。 越接近软件发布的最终期限，代码也就不能改得太多。 我个人的习惯，并且也是对团队成员的要求是——先Review设计实现思路，然后Review设计模式，接着Review成形的骨干代码，最后Review完成的代码，如果程序复杂的话，需要拆成几个单元或模块分别Review。当然，最佳的practice是，每次Review的代码应该在1000行以内，时间不能超过一部电影的时间——1.5小时（因为据说那个一个正常人的膀胱可以容纳尿液的最长限度）
当然，在敏捷开发中，他们不需要Code Reivew，其实，敏捷开发中使用更为极端的“结对编程”（Pair-Programming）的方法 —— 一种时时刻刻都在进行Code Review的方法，个人感觉在实际过程中，这种方法有点过了。另外，大家可以看看本站的另一篇文章《结对编程的利与弊》来了解一下这种方法的问题。
3.- 尽可能的让不同的人Reivew你的代码 这是一个好主意，如果可能的话，不要总是只找一个人来Review你的代码，不同的人有不同的思考方式，有不同的见解，所以，不同的人可以全面的从各个方面评论你的代码，有的从实现的角度，有的从需求的角度，有的从用户使用的角度，有的从算法的角度，有的从性能效率的角度，有的从易读的角度，有的从扩展性的角度……，啊，好多啊，还让不让人活了。不管怎么说，多找一些不同的人会对你很有好处。当然，不要太多了，人多嘴杂反而适得其反，基本上来说，不要超过3个人，这是因为，这是一个可以围在一起讨论的最大人员尺寸。</description>
    </item>
    
    <item>
      <title></title>
      <link>./norm/plan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./norm/plan/</guid>
      <description>new T1 算法 Schedule 48 所有时间估计实施时长乘系数 0.5~3
程序 apps 23.5 + 3*?  bills 4.5  list 1&amp;frasl;4 get 1&amp;frasl;4 入库 1 出库 1 指定单据入库退货manual 1 指定单据出库退货manual 1  stocks 11 + ? + ? + ?
 app.stocks 3 + ?  入库 1&amp;frasl;4 出库 1&amp;frasl;4 list 1&amp;frasl;8 get 1&amp;frasl;8 指定单据入库退货manual 1 指定单据出库退货manual 5&amp;frasl;4 修改 ？？  api.settlement 3 + ?  入库 1&amp;frasl;4 出库 1&amp;frasl;4 list 1&amp;frasl;8 get 1&amp;frasl;8 指定单据入库退货manual 1 指定单据出库退货manual 5&amp;frasl;4 修改 ？？  关联表 1  出库关联 1&amp;frasl;8 关联修改 1&amp;frasl;8 关联调用 3&amp;frasl;4  app.</description>
    </item>
    
  </channel>
</rss>