<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Viemacs Notes</title>
    <link>./</link>
    <description>Recent content on Viemacs Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 22 Jul 2017 11:51:17 +0800</lastBuildDate>
    
	<atom:link href="./index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>AI</title>
      <link>./access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./access/</guid>
      <description> An Introduction We trust you have received the usual lecture from the local System Administrator. It usually boils down to these three things:
 1) Respect the privacy of others. 2) Think before you type. 3) With great power comes great responsibility.  </description>
    </item>
    
    <item>
      <title>Algorithm</title>
      <link>./algorithm/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./algorithm/access/</guid>
      <description> Algorithm </description>
    </item>
    
    <item>
      <title>Algorithm</title>
      <link>./algorithm/huffman/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./algorithm/huffman/</guid>
      <description>Huffman Encoding class Node(object): def __init__(self, symbol = &amp;#39;&amp;#39;, weight = 0, left = None, right = None): self.symbol, self.weight, self.left, self.right = symbol, weight, left, right if (left and right): self.weight = left.weight + right.weight def result(self, code = &amp;#39;&amp;#39;): r = [] self.symbol and r.append((self.symbol, self.weight, code)) self.left and r.extend(self.left.result(code + &amp;#39;0&amp;#39;)) self.right and r.extend(self.right.result(code + &amp;#39;1&amp;#39;)) return r def genHuffman(char, freq): nodeList = [] for i in range(len(char)): nodeList.</description>
    </item>
    
    <item>
      <title>C</title>
      <link>./c/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./c/access/</guid>
      <description> C </description>
    </item>
    
    <item>
      <title>C</title>
      <link>./c/memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./c/memory/</guid>
      <description>Memory 内存分配方式中的 栈、堆、自由存储区、全局与静态存储区、常量存储区  栈
栈是由编译器管理的变量存储区，在需要时分配，在不需要时自动释放。用户栈位于用户进程地址空间的顶部，在执行期间可以动态地扩展和收缩。栈中的变量有局部变量、函数参数，编译器也会用栈来实现函数调用。
 堆
堆是由用户程序主动管理的内存块，编译器不做管理。堆上的内存用 new 分配，用 delete 释放。没有释放的内存在用户程序结束后由操作系统回收。堆可以*动态地扩展和收缩*。
 自由存储区
自由存储区和堆相似。自由存储区的内存用 malloc 分配，用 free 释放。
 全局与静态存储区
全局变量和静态变量的内存存储区。在 C++ 中为一块内存区。在 C 中，静态变量和初始化的全局变量在一块内存区，未初始化的全局变量在相邻的内存区。可通过 void* 来操作未初始化变量的存储区。全局和静态变量都在程序结束时由系统进行释放。
 常量存储区
常量存储，不允许修改其中的变量。
  堆栈的区别 堆和栈的区别是大家常说起的一个问题。
#include &amp;lt;stdlib.h&amp;gt; int main() { int* a = (int*) malloc(4); free(a); return 0; }  指针 a 在栈上分配了一段内存，malloc 在堆上分配了一段4个整型大小的内存，然后把这段内存的首地址返回给指针 a。
堆和栈的区别主要有5点。（中文中“堆栈”指栈。）
 管理方式
栈由编译器自动管理；堆由用户程序主动管理，显示进行分配和释放。
 空间大小
栈一般有一定的空间大小，而且默认的空间大小较小，例如1M；而堆在32位系统下的地址空间就可以达到4G。
 碎片
栈是 FILO 队列，永远不会从中间 pop 内存块。而堆在大量的 malloc/free, new/delete 内存空间会产生许多的不连续，生成内存碎片。</description>
    </item>
    
    <item>
      <title>Editor</title>
      <link>./editor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./editor/</guid>
      <description>Editor Emacs Emacs Config File init.el</description>
    </item>
    
    <item>
      <title>Editor</title>
      <link>./editor/vim_shortcuts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./editor/vim_shortcuts/</guid>
      <description>VIM Shortcuts 退出  w filename: 保存正在编辑的文件filename wq filename: 保存后退出正在编辑的文件filename q：退出不保存。  窗口操作  ctrl+w p: 在两个分割窗口之间来回切换。 ctrl+w j: 跳到下面的分割窗 ctrl+w h: 跳到左边的分割窗。 ctrl+w k: 跳到上面的分割窗。 ctrl+w l: 跳到右边的分割窗。  移动 h,j,k,l: 左，下，上，右。 w: 下一个词的词首。 e:下一个词的词尾。 b:上一个词的词首。 &amp;lt;&amp;gt;: v 模式选中后进行缩进。  跳转 %: 可以匹配{},&amp;quot;&amp;quot;,(),[]之间跳转。 H、M、L：直接跳转到当前屏幕的顶部、中部、底部。 #H：跳转到当前屏的第#行。 #L：跳转到当前屏的倒数第#行。 zt: 当前编辑行置为屏顶。 zz: 当前编辑行置为屏中。 zb: 当前编辑行置为屏底。 G：直接跳转到文件的底部。 gg: 跳转到文件首。 ():跳转到当前的行首、行尾。 {}：向上、向下跳转到最近的空行。 [{：跳转到目前区块开头。 ]}：跳转到目前区块结尾。 0: 跳转到行首。 $: 跳转到行尾。 2$: 跳转到下一行的行尾。 #：跳转到该行的第#个位置。 #G: 15G,跳转到15行。 :#：跳转到#行。 f&#39;n&#39;：跳转到下一个&amp;quot;n&amp;quot;字母后。 ctrl+b: 向后翻一页。 ctrl+f：向前翻一页。 ctrl+u: 向后翻半页。 ctrl+d: 向前翻半页。 ctry+e: 下滚一行。  选择 1.</description>
    </item>
    
    <item>
      <title>Errors</title>
      <link>./errors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./errors/</guid>
      <description>Errors This error section is stored in a separate file, errors.md. DocuAPI allows you to split the single page documentation in as many files as needed. Files are included in the default Hugo page order . One way of ordering the pages is by setting the page `weight` in the front matter. Pages with lower weight will be listed first. The Kittn API uses the following error codes:
   Error Code Meaning     400 Bad Request &amp;ndash; Your request sucks   401 Unauthorized &amp;ndash; Your API key is wrong   403 Forbidden &amp;ndash; The kitten requested is hidden for administrators only   404 Not Found &amp;ndash; The specified kitten could not be found   405 Method Not Allowed &amp;ndash; You tried to access a kitten with an invalid method   406 Not Acceptable &amp;ndash; You requested a format that isn&amp;rsquo;t json   410 Gone &amp;ndash; The kitten requested has been removed from our servers   418 I&amp;rsquo;m a teapot   429 Too Many Requests &amp;ndash; You&amp;rsquo;re requesting too many kittens!</description>
    </item>
    
    <item>
      <title>GO</title>
      <link>./go/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./go/access/</guid>
      <description>Golang The Design Go 看上去是 C 而不是 C++。我自己在学习和项目使用时，并没有很在意 C 和 C++ 的区别，但看到 Go 时，发现了许多不同。
package foobar type Bar struct { n int } func (b *Bar) foo() int { return b.n }  Go 语言在设计中的感觉是追求显式表达，避免隐式表达。
class Bar(object): n = &amp;quot;a local variable&amp;quot; def __init__(self): self.n = 0 def foo(self): pass  Python 中也有相似的地方，在类中显式地写出self，对self的操作才是对对象的操作。
但 Go 中向对象增加方法method也要显式地写出对象。
Go 中不支持参数默认值，函数重载。C 也不支持，是 C++ 支持。
参数默认值其实是一种隐式表达。调用者仅看名字，不去查看默认参数时，有时会遇到参数默认值导致问题，给调试带来不少麻烦。
一个表达的意义应该是唯一的，没有二义性。凡是可能导致二义性的行为都应是禁止或尽量避免的。比如函数默认参数，比如类的默认拷贝构造函数。还有一个书写方便但让项目更难调试的功能：自动类型转换。
进一步，一种表达的写法也应尽可能是唯一的。在 Go 语言的写法中，就没有单行 if 语句要不要加括号/braces 这样的问题。if else 中 else 的位置也是固定的。另一方面，你可以用无条件的 switch 来更清楚地表达 if-then-else。</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/access/</guid>
      <description>Javascript Thoughts Why JavaScript I use JavaScript to develop products because it seems faster and easier. Use web browsers as JVM, use DOM to build UI, and sue JS to implement business logic.
React React provides a different way of organize frontend codes. And I like it very much.
Before writing WebApp, my programming practice uses Cpp mostly. So class and components are very handy, and very easy to understand.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/develop-environment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/develop-environment/</guid>
      <description>JS Development Environment 随着前端和 Node.JS 的发展, 以及页面的APP化, JS 成为开发应用的不错的选择. 前后通吃, 语法灵活, 发展迅速, 对提高开发效率很有帮助.
JS 开发发展迅速带来的一个问题是工具和库众多, 开发中选择什么工具成了一个问题. 我从两年前真正开始写JS开始尝试了一些工具和库, 试过之后才知道什么更适合自己.
编辑器 单就文本编辑器而言, 当然还是首推 Emacs 和 Vim. 除这两者之外, 还有许多不错和编辑器和IDE.
 Sublime 比较灵活, 有插件, 可配置. 上手容易, 但要用上各种插件有点繁. Atom 比较适合前端技术栈, github 出品, 应该不错. 没真正用过. Brackets 使用时感觉很方便, web 预览功能很不错. 当时版本较早, 有一些bug, 现在应该更好用了. WebStorm 完整的 IDE 的样子, 对 JS 开发非常不错, 前端, Node.JS, git 都支持, 也有 emacs 模式. 用习惯之后对生产效率应该会有提升.  打包 打包包括了开发上线所需的预编译, 压缩, 转换, 优化, 构建任务.
现在使用的是 Webpack.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/es2015/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/es2015/</guid>
      <description>Core Features of ES2015 (ES6) Note on Adrain Mejia&amp;rsquo;s article
History ES6, a.k.a. ES2015+, ECMAScript6.
Javascript is evolving since it was created, and ES6 is now well supported in all modern browsers.
(compatibility ref)
ES6 core features block-scoped variables We know that var is not block-scoped, but function scoped. In ES6, let and const is used instead of var to limit variable scoped to block. let is the better var A variable must be defined before use when it&amp;rsquo;s defined by let, and it exists only inside its block, like a for-loop or if-block.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/expressjs_note/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/expressjs_note/</guid>
      <description>Note on Express Basic Routing A route method is derived from one of the HTTP methods, and is attached to an instance of the express class.
Route methods Express supports the following routing methods that correspond to HTTP methods: get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, and connect.
To route methods that translate to invalid JavaScript variable names, use the bracket notation.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/nodejs-mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/nodejs-mysql/</guid>
      <description>MySQL in NodeJS 1. 建立数据库连接 createConnection(Object) 该方法接受一个对象作为参数，该对象有四个常用的属性host，user，password，database。与php中链接数据库的参数相同。属性列表如下：
host: 连接数据库所在的主机名. (默认: localhost) port: 连接端口. (默认: 3306) localAddress: 用于TCP连接的IP地址. (可选) socketPath: 链接到unix域的路径。在使用host和port时该参数会被忽略. user: MySQL用户的用户名. password: MySQL用户的密码. database: 链接到的数据库名称 (可选). charset: 连接的字符集. (默认: &amp;#39;UTF8_GENERAL_CI&amp;#39;.设置该值要使用大写!) timezone: 储存本地时间的时区. (默认: &amp;#39;local&amp;#39;) stringifyObjects: 是否序列化对象. See issue #501. (默认: &amp;#39;false&amp;#39;) insecureAuth: 是否允许旧的身份验证方法连接到数据库实例. (默认: false) typeCast: 确定是否讲column值转换为本地JavaScript类型列值. (默认: true) queryFormat: 自定义的查询语句格式化函数. supportBigNumbers: 数据库处理大数字(长整型和含小数),时应该启用 (默认: false). bigNumberStrings: 启用 supportBigNumbers和bigNumberStrings 并强制这些数字以字符串的方式返回(默认: false). dateStrings: 强制日期类型(TIMESTAMP, DATETIME, DATE)以字符串返回，而不是一javascript Date对象返回. (默认: false) debug: 是否开启调试.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/oop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/oop/</guid>
      <description>Object-Oriented Programming of Javascript notes of 1 2 3
JS 的对象 JS 本身是基于对象的语言，在 JS 中所操作的基本都是对象。但在 ES2015 之前它又没有 class 的类。
 对象实例  let record = { name: &amp;#39;&amp;#39;, nation: &amp;#39;&amp;#39; };  Schema 规格
let record1 = { name: &amp;#39;Alpha&amp;#39;, nation: &amp;#39;China&amp;#39; }; let record2 = { name: &amp;#39;Beta, nation: &amp;#39;Denmark&amp;#39; };  给对象赋予属性和方法</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/performance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/performance/</guid>
      <description>Practice of JavaScript Performance Since JavaScript becomes a fullstack programming language, in certain cases the performance of JS is critical. Here are some practice of JS, with some understanding of JS implementation.
Data Store How a variable is create will effect its performance. - Use {} instead of new Object, use [] instead of new Array, use plain string instead of an object. - Use local temporary variable to store variable deep upon the data-chain, and values require many calculation.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/webpack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/webpack/</guid>
      <description>An Introduction to Webpack Webpack is a bundler for javascript, and related resources. All resources are treated as modules, and with various loaders, webpack can handle modules of CommonJs, AMD, ES6, CSS, Image, JSON, Coffeescript, LESS, etc.
// what a webpack config file &#39;webpack.config.js&#39; looks like module: { loaders: [ { test: /\.css$/, loader: &#39;style!css&#39; }, // use ! to chain loaders { test: /\.js$/, loader: &#39;jsx?harmony!babel&#39;, exclude: /node_modules/ } // loaders can be written like &#39;jsx-loader&#39; or &#39;jsx&#39; // loaders can take parameters as a querystring ] }  Entrance and output.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/z-webpack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/z-webpack/</guid>
      <description>Another Webpack Note  其实Webpack的入门指导文章非常多，配置方式也各有各样，这里我推荐题叶大神的入门级指南–Webpack 入门指迷，如果不知道Webpack是什么或者不是很清楚各项配置含义的开发者，可以看此文章扫扫盲。毕竟我这篇文章并不是特别基础。 
1. base.js var path = require(&amp;lsquo;path&amp;rsquo;) var baseConfig = { resolve: { extensions: [&amp;ldquo;, &amp;lsquo;.js&amp;rsquo;], fallback: [path.join(dirname, &amp;lsquo;../node_modules&amp;rsquo;)], alias: { &amp;lsquo;src&amp;rsquo;: path.resolve(dirname, &amp;lsquo;../src&amp;rsquo;), &amp;lsquo;assets&amp;rsquo;: path.resolve(dirname, &amp;lsquo;../src/assets&amp;rsquo;), &amp;lsquo;components&amp;rsquo;: path.resolve(dirname, &amp;lsquo;../src/components&amp;rsquo;) } }, module: { loaders: [{ test: /.js$/, loader: &amp;lsquo;babel&amp;rsquo;, exclude: /node_modules/ }, { test: /.(png|jpe?g|gif|svg|woff2?|eot|ttf|otf)(\?.*)?$/, loader: &amp;lsquo;url?limit=8192&amp;amp;context=client&amp;amp;name=[path][name].[hash:7].[ext]&amp;rsquo; }, { test: /.css$/, loader: &amp;lsquo;style!css!autoprefixer&amp;rsquo;, }, { test: /.scss$/, loader: &amp;lsquo;style!css!autoprefixer!sass&amp;rsquo; }] } };</description>
    </item>
    
    <item>
      <title>Norm</title>
      <link>./norm/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./norm/access/</guid>
      <description> Norm </description>
    </item>
    
    <item>
      <title>Norm</title>
      <link>./norm/code-review/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./norm/code-review/</guid>
      <description>Code Review 为什么做 Code Review 做 Code review 是为了改进代码质量. 通过对代码, 测试过程和注释进行检查, 来确认方案设计和代码实现.
Code review 的主要目的:
 保证代码质量   程序逻辑 需求和设计的实现 查找和排除系统缺陷 可读性 可维护性
 保证项目组人员的良好沟通
 项目或产品的代码更容易维护
   提高参与者开发水平 传递作者的意图和想法，使其他人可以更加熟悉代码，利于维护代码和改进代码 评审过程使大家更多的理解系统，重构思路， 确定作者的设计和实现清晰，简单 帮助初级开发人员学习高级开发人员的经验，达到知识共享, 相互学习，提高开发者水平  次要目的: - 查找程序的bug - 保证代码风格和编码标准 - 编码风格 - 避免开发人员犯一些很常见，很普通的错误 - 在项目早期就能够发现代码中的BUG
消除 Bug 主要靠测试. 由单元测试，功能测试，性能测试，回归测试来消除Bug。 单元测试为主。单元测试最接近bug，bug没有扩散的地方。 在 code review 之前，要有单元测试和单元测试报告，
代码风格和编码标准是确定的, 是靠个人可以做到的, 所以在代码提交时就应该是符合规范的。 代码规范，有作者自己和一些检查代码规范的工具。
规范性 - 注释格式 - 命名规范
 异常处理 日志处理 代码组织结构</description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>./sql/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./sql/access/</guid>
      <description> SQL </description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>./sql/variable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./sql/variable/</guid>
      <description>Declare a Variable in MySQL (ref)
There are mainly three types of variables in MySQL:
User-defined variables (prefixed with @):
You can access any user-defined variable without declaring it or initializing it. If you refer to a variable that has not been initialized, it has a value of NULL and a type of string.
SELECT @var_any_var_name You can initialize a variable using SET or SELECT statement:
SET @start = 1, @finish = 10;</description>
    </item>
    
    <item>
      <title>Tools</title>
      <link>./tools/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./tools/access/</guid>
      <description> Tools </description>
    </item>
    
    <item>
      <title>Tools</title>
      <link>./tools/makefile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./tools/makefile/</guid>
      <description>Makefile Make Basic make is designed to manage the compiling process based on dependencies. The other functions of make is designed to make it easier to write Makefile.
When we deal with a complex project, there might be lots of source files, header files, lib files, target files. The files have a certain dependency relationship.
$ gcc -c -o test.o test.c $ gcc -o helloworld test.o  The dependency line is: test.</description>
    </item>
    
    <item>
      <title>Index</title>
      <link>./python/</link>
      <pubDate>Sat, 22 Jul 2017 11:51:17 +0800</pubDate>
      
      <guid>./python/</guid>
      <description>Python Class 自带函数 class Foor(object): def __init__(self, *args, **kwargs): print(&amp;#39;init&amp;#39;) super(Bar, self).__init__(*args, **kwargs) def __new__(cls, *args, **kwargs): print(&amp;#39;new&amp;#39;) return super(Bar, cls).__new__(cls, *args, **kwargs) def __call__(self, *args, **kwargs): print(&amp;#39;call&amp;#39;) foo = Bar() foo() # Result: new init call   __init__(self, *args, **kwargs)
在对象创建完成后调用，对当前对象实例进行初始化，无返回值。
 __new__(cls, *args, **kwargs)
创建对象时调用，返回当前对象的一个实例。
 __call__(self, *args, **kwargs)
重载括号运算符。类实现了call方法，则其对象可当作函数使用。
  用自带函数实现单例 class MySingleton(object): def __new__(cls, *args, **kwargs): if not &amp;#39;_instance&amp;#39; in vars(cls): cls._instance = super(MySingleton, cls).</description>
    </item>
    
    <item>
      <title>Index</title>
      <link>./network/</link>
      <pubDate>Fri, 21 Jul 2017 23:10:37 +0800</pubDate>
      
      <guid>./network/</guid>
      <description> Network header 2 inline code
int main(){return 0;}  some code in python
def foo(): pass  </description>
    </item>
    
    <item>
      <title>Layers</title>
      <link>./network/layers/</link>
      <pubDate>Thu, 20 Jul 2017 11:16:50 +0800</pubDate>
      
      <guid>./network/layers/</guid>
      <description></description>
    </item>
    
    <item>
      <title>About</title>
      <link>./about/</link>
      <pubDate>Thu, 20 Jul 2017 09:50:48 +0800</pubDate>
      
      <guid>./about/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>./norm/code_review/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./norm/code_review/</guid>
      <description>review 记录：作者记录，表格记录，checkout -b review， checkout -b review_by_Foo, git pull &amp;amp;&amp;amp; checkout -b review_by_Foo
http://blog.csdn.net/haoel/article/details/4469526
http://blog.csdn.net/haoel/article/details/4469462
http://www.cnblogs.com/lhb25/p/15-best-code-review-tools-for-developers.html
Code Review中的几个提示
Code Review应该是软件工程最最有价值的一个活动，之前，本站发表过《简单实用的Code Review工具》，那些工具主要是用来帮助更有效地进行这个活动，这里的这篇文章，我们主要想和大家分享一下Code Review代码审查的一些心得。
首先，我们先来看看Code Reivew的用处：
Code reviews 中，可以通过大家的建议增进代码的质量。 Code reviews 是一个传递知识的手段，可以让其它并不熟悉代码的人知道作者的意图和想法，从而可以在以后轻松维护代码。 Code reviews 也鼓励程序员们相互学习对方的长处和优点。 Code reviews 也可以被用来确认自己的设计和实现是一个清楚和简单的。 你也许注意到了在上面的Code Reivew中的诸多用处中，我们没有提到可以帮助找到程序的bug和保证代码风格和编码标准。这是因为我们认为：
Code reviews 不应该承担发现代码错误的职责。Code Review主要是审核代码的质量，如可读性，可维护性，以及程序的逻辑和对需求和设计的实现。代码中的bug和错误应该由单元测试，功能测试，性能测试，回归测试来保证的（其中主要是单元测试，因为那是最接近Bug，也是Bug没有扩散的地方）
所以，在今天，请不要把上面的那两件事分散了Code Review的注意力，取而代之的是，对于Bug，程序的作者要在Review前提交自己的单元测试报告（如：XUnit的测试结果），对于代码规范，这是程序作者自己需要保证的，而且，有一些工具是可以帮你来检查代码规范的。
不是说不能在Code Review中报告一个程序的bug或是一个代码规范的问题。只是说那并不是Code Review的意图。
1.- 经常进行Code Review 以前经历过几个相当痛苦的Code Review，那几次Code Review都是在程序完成的时候进行的，当你面对那近万行的代码，以前N我掺和在一起的功能，你会发现，整个Code Review变得非常地艰难，用不了一会儿，你就会发现大家都在拼命地打着哈欠，但还是要坚持，有时候，这样的Review会持续3个小时以上，相当的夸张。而且，会议上会出现相当多的问题和争论，因为，这就好像，人家都把整个房子盖好了，大家Review时这挑一点那挑一点，有时候触动地基或是承重墙体，需要大动手术，让人返工，这当然会让盖房的人一下就跳起来极力地维护自己的代码，最后还伤了团队成员的感情。
所以，千万不要等大厦都盖好了再去Reivew，而且当有了地基，有了框架，有了房顶，有了门窗，有了装修，的各个时候循序渐进地进行Review，这样反而会更有效率，也更有帮助。
下面是一些观点，千万要铭记：
要Review的代码越多，那么要重构，重写的代码就会越多。而越不被程序作者接受的建议也会越多，唾沫口水战也会越多。 程序员代码写得时候越长，程序员就会在代码中加入越来越多的个人的东西。 程序员最大的问题就是“自负”，无论什么时候，什么情况下，有太多的机会会让这种“自负”澎涨开来，并开始影响团队影响整个项目，以至于听不见别人的建议，从而让Code Review变成了口水战。 越接近软件发布的最终期限，代码也就不能改得太多。 我个人的习惯，并且也是对团队成员的要求是——先Review设计实现思路，然后Review设计模式，接着Review成形的骨干代码，最后Review完成的代码，如果程序复杂的话，需要拆成几个单元或模块分别Review。当然，最佳的practice是，每次Review的代码应该在1000行以内，时间不能超过一部电影的时间——1.5小时（因为据说那个一个正常人的膀胱可以容纳尿液的最长限度）
当然，在敏捷开发中，他们不需要Code Reivew，其实，敏捷开发中使用更为极端的“结对编程”（Pair-Programming）的方法 —— 一种时时刻刻都在进行Code Review的方法，个人感觉在实际过程中，这种方法有点过了。另外，大家可以看看本站的另一篇文章《结对编程的利与弊》来了解一下这种方法的问题。
3.- 尽可能的让不同的人Reivew你的代码 这是一个好主意，如果可能的话，不要总是只找一个人来Review你的代码，不同的人有不同的思考方式，有不同的见解，所以，不同的人可以全面的从各个方面评论你的代码，有的从实现的角度，有的从需求的角度，有的从用户使用的角度，有的从算法的角度，有的从性能效率的角度，有的从易读的角度，有的从扩展性的角度……，啊，好多啊，还让不让人活了。不管怎么说，多找一些不同的人会对你很有好处。当然，不要太多了，人多嘴杂反而适得其反，基本上来说，不要超过3个人，这是因为，这是一个可以围在一起讨论的最大人员尺寸。</description>
    </item>
    
    <item>
      <title></title>
      <link>./norm/plan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./norm/plan/</guid>
      <description>new T1 算法 Schedule 48 所有时间估计实施时长乘系数 0.5~3
程序 apps 23.5 + 3*?  bills 4.5  list 1&amp;frasl;4 get 1&amp;frasl;4 入库 1 出库 1 指定单据入库退货manual 1 指定单据出库退货manual 1  stocks 11 + ? + ? + ?
 app.stocks 3 + ?  入库 1&amp;frasl;4 出库 1&amp;frasl;4 list 1&amp;frasl;8 get 1&amp;frasl;8 指定单据入库退货manual 1 指定单据出库退货manual 5&amp;frasl;4 修改 ？？  api.settlement 3 + ?  入库 1&amp;frasl;4 出库 1&amp;frasl;4 list 1&amp;frasl;8 get 1&amp;frasl;8 指定单据入库退货manual 1 指定单据出库退货manual 5&amp;frasl;4 修改 ？？  关联表 1  出库关联 1&amp;frasl;8 关联修改 1&amp;frasl;8 关联调用 3&amp;frasl;4  app.</description>
    </item>
    
  </channel>
</rss>