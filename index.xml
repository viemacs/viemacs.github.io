<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Viemacs Notes</title>
    <link>./</link>
    <description>Recent content on Viemacs Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 22 Jul 2017 11:51:17 +0800</lastBuildDate>
    
	<atom:link href="./index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>viEmacs Listing Page</title>
      <link>./</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./</guid>
      <description>Introduction Welcome to the Kittn API! You can use our API to access Kittn API endpoints, which can get information on various cats, kittens, and breeds in our database.
We have language bindings in Shell, Ruby, and Python! You can view code examples in the dark area to the right, and you can switch the programming language of the examples with the tabs in the top right.
This example API documentation page was created with DocuAPI, a multilingual documentation theme for the static site generator Hugo.</description>
    </item>
    
    <item>
      <title>Algorithm</title>
      <link>./algorithm/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./algorithm/access/</guid>
      <description> Algorithm </description>
    </item>
    
    <item>
      <title>Algorithm</title>
      <link>./algorithm/huffman/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./algorithm/huffman/</guid>
      <description>Huffman Encoding class Node(object): def __init__(self, symbol = &amp;#39;&amp;#39;, weight = 0, left = None, right = None): self.symbol, self.weight, self.left, self.right = symbol, weight, left, right if (left and right): self.weight = left.weight + right.weight def result(self, code = &amp;#39;&amp;#39;): r = [] self.symbol and r.append((self.symbol, self.weight, code)) self.left and r.extend(self.left.result(code + &amp;#39;0&amp;#39;)) self.right and r.extend(self.right.result(code + &amp;#39;1&amp;#39;)) return r def genHuffman(char, freq): nodeList = [] for i in range(len(char)): nodeList.</description>
    </item>
    
    <item>
      <title>Editor</title>
      <link>./editor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./editor/</guid>
      <description>Editor Emacs Emacs Config File init.el</description>
    </item>
    
    <item>
      <title>Editor</title>
      <link>./editor/vim_shortcuts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./editor/vim_shortcuts/</guid>
      <description>VIM Shortcuts 退出  w filename: 保存正在编辑的文件filename wq filename: 保存后退出正在编辑的文件filename q：退出不保存。  窗口操作  ctrl+w p: 在两个分割窗口之间来回切换。 ctrl+w j: 跳到下面的分割窗 ctrl+w h: 跳到左边的分割窗。 ctrl+w k: 跳到上面的分割窗。 ctrl+w l: 跳到右边的分割窗。  移动 h,j,k,l: 左，下，上，右。 w: 下一个词的词首。 e:下一个词的词尾。 b:上一个词的词首。 &amp;lt;&amp;gt;: v 模式选中后进行缩进。  跳转 %: 可以匹配{},&amp;quot;&amp;quot;,(),[]之间跳转。 H、M、L：直接跳转到当前屏幕的顶部、中部、底部。 #H：跳转到当前屏的第#行。 #L：跳转到当前屏的倒数第#行。 zt: 当前编辑行置为屏顶。 zz: 当前编辑行置为屏中。 zb: 当前编辑行置为屏底。 G：直接跳转到文件的底部。 gg: 跳转到文件首。 ():跳转到当前的行首、行尾。 {}：向上、向下跳转到最近的空行。 [{：跳转到目前区块开头。 ]}：跳转到目前区块结尾。 0: 跳转到行首。 $: 跳转到行尾。 2$: 跳转到下一行的行尾。 #：跳转到该行的第#个位置。 #G: 15G,跳转到15行。 :#：跳转到#行。 f&#39;n&#39;：跳转到下一个&amp;quot;n&amp;quot;字母后。 ctrl+b: 向后翻一页。 ctrl+f：向前翻一页。 ctrl+u: 向后翻半页。 ctrl+d: 向前翻半页。 ctry+e: 下滚一行。  选择 1.</description>
    </item>
    
    <item>
      <title>Errors</title>
      <link>./errors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./errors/</guid>
      <description>Errors This error section is stored in a separate file, errors.md. DocuAPI allows you to split the single page documentation in as many files as needed. Files are included in the default Hugo page order . One way of ordering the pages is by setting the page `weight` in the front matter. Pages with lower weight will be listed first. The Kittn API uses the following error codes:
   Error Code Meaning     400 Bad Request &amp;ndash; Your request sucks   401 Unauthorized &amp;ndash; Your API key is wrong   403 Forbidden &amp;ndash; The kitten requested is hidden for administrators only   404 Not Found &amp;ndash; The specified kitten could not be found   405 Method Not Allowed &amp;ndash; You tried to access a kitten with an invalid method   406 Not Acceptable &amp;ndash; You requested a format that isn&amp;rsquo;t json   410 Gone &amp;ndash; The kitten requested has been removed from our servers   418 I&amp;rsquo;m a teapot   429 Too Many Requests &amp;ndash; You&amp;rsquo;re requesting too many kittens!</description>
    </item>
    
    <item>
      <title>Tools</title>
      <link>./tools/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./tools/access/</guid>
      <description> Tools </description>
    </item>
    
    <item>
      <title>Tools</title>
      <link>./tools/makefile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./tools/makefile/</guid>
      <description>Makefile Make Basic make is designed to manage the compiling process based on dependencies. The other functions of make is designed to make it easier to write Makefile.
When we deal with a complex project, there might be lots of source files, header files, lib files, target files. The files have a certain dependency relationship.
$ gcc -c -o test.o test.c $ gcc -o helloworld test.o  The dependency line is: test.</description>
    </item>
    
    <item>
      <title>Index</title>
      <link>./python/</link>
      <pubDate>Sat, 22 Jul 2017 11:51:17 +0800</pubDate>
      
      <guid>./python/</guid>
      <description>Python Class 自带函数 class Foor(object): def __init__(self, *args, **kwargs): print(&amp;#39;init&amp;#39;) super(Bar, self).__init__(*args, **kwargs) def __new__(cls, *args, **kwargs): print(&amp;#39;new&amp;#39;) return super(Bar, cls).__new__(cls, *args, **kwargs) def __call__(self, *args, **kwargs): print(&amp;#39;call&amp;#39;) foo = Bar() foo() # Result: new init call   __init__(self, *args, **kwargs)
在对象创建完成后调用，对当前对象实例进行初始化，无返回值。
 __new__(cls, *args, **kwargs)
创建对象时调用，返回当前对象的一个实例。
 __call__(self, *args, **kwargs)
重载括号运算符。类实现了call方法，则其对象可当作函数使用。
  用自带函数实现单例 class MySingleton(object): def __new__(cls, *args, **kwargs): if not &amp;#39;_instance&amp;#39; in vars(cls): cls._instance = super(MySingleton, cls).</description>
    </item>
    
    <item>
      <title>Index</title>
      <link>./network/</link>
      <pubDate>Fri, 21 Jul 2017 23:10:37 +0800</pubDate>
      
      <guid>./network/</guid>
      <description> Network header 2 inline code
int main(){return 0;}  some code in python
def foo(): pass  </description>
    </item>
    
    <item>
      <title>Layers</title>
      <link>./network/layers/</link>
      <pubDate>Thu, 20 Jul 2017 11:16:50 +0800</pubDate>
      
      <guid>./network/layers/</guid>
      <description></description>
    </item>
    
    <item>
      <title>About</title>
      <link>./about/</link>
      <pubDate>Thu, 20 Jul 2017 09:50:48 +0800</pubDate>
      
      <guid>./about/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>