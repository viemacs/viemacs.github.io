<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Js on Viemacs Notes</title>
    <link>./js/</link>
    <description>Recent content in Js on Viemacs Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="./js/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JS</title>
      <link>./js/access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/access/</guid>
      <description>Javascript Thoughts Why JavaScript I use JavaScript to develop products because it seems faster and easier. Use web browsers as JVM, use DOM to build UI, and sue JS to implement business logic.
React React provides a different way of organize frontend codes. And I like it very much.
Before writing WebApp, my programming practice uses Cpp mostly. So class and components are very handy, and very easy to understand.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/develop-environment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/develop-environment/</guid>
      <description>JS Development Environment 随着前端和 Node.JS 的发展, 以及页面的APP化, JS 成为开发应用的不错的选择. 前后通吃, 语法灵活, 发展迅速, 对提高开发效率很有帮助.
JS 开发发展迅速带来的一个问题是工具和库众多, 开发中选择什么工具成了一个问题. 我从两年前真正开始写JS开始尝试了一些工具和库, 试过之后才知道什么更适合自己.
编辑器 单就文本编辑器而言, 当然还是首推 Emacs 和 Vim. 除这两者之外, 还有许多不错和编辑器和IDE.
 Sublime 比较灵活, 有插件, 可配置. 上手容易, 但要用上各种插件有点繁. Atom 比较适合前端技术栈, github 出品, 应该不错. 没真正用过. Brackets 使用时感觉很方便, web 预览功能很不错. 当时版本较早, 有一些bug, 现在应该更好用了. WebStorm 完整的 IDE 的样子, 对 JS 开发非常不错, 前端, Node.JS, git 都支持, 也有 emacs 模式. 用习惯之后对生产效率应该会有提升.  打包 打包包括了开发上线所需的预编译, 压缩, 转换, 优化, 构建任务.
现在使用的是 Webpack.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/es2015/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/es2015/</guid>
      <description>Core Features of ES2015 (ES6) Note on Adrain Mejia&amp;rsquo;s article
History ES6, a.k.a. ES2015+, ECMAScript6.
Javascript is evolving since it was created, and ES6 is now well supported in all modern browsers.
(compatibility ref)
ES6 core features block-scoped variables We know that var is not block-scoped, but function scoped. In ES6, let and const is used instead of var to limit variable scoped to block. let is the better var A variable must be defined before use when it&amp;rsquo;s defined by let, and it exists only inside its block, like a for-loop or if-block.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/expressjs_note/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/expressjs_note/</guid>
      <description>Note on Express Basic Routing A route method is derived from one of the HTTP methods, and is attached to an instance of the express class.
Route methods Express supports the following routing methods that correspond to HTTP methods: get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, and connect.
To route methods that translate to invalid JavaScript variable names, use the bracket notation.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/nodejs-mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/nodejs-mysql/</guid>
      <description>MySQL in NodeJS 1. 建立数据库连接 createConnection(Object) 该方法接受一个对象作为参数，该对象有四个常用的属性host，user，password，database。与php中链接数据库的参数相同。属性列表如下：
host: 连接数据库所在的主机名. (默认: localhost) port: 连接端口. (默认: 3306) localAddress: 用于TCP连接的IP地址. (可选) socketPath: 链接到unix域的路径。在使用host和port时该参数会被忽略. user: MySQL用户的用户名. password: MySQL用户的密码. database: 链接到的数据库名称 (可选). charset: 连接的字符集. (默认: &amp;#39;UTF8_GENERAL_CI&amp;#39;.设置该值要使用大写!) timezone: 储存本地时间的时区. (默认: &amp;#39;local&amp;#39;) stringifyObjects: 是否序列化对象. See issue #501. (默认: &amp;#39;false&amp;#39;) insecureAuth: 是否允许旧的身份验证方法连接到数据库实例. (默认: false) typeCast: 确定是否讲column值转换为本地JavaScript类型列值. (默认: true) queryFormat: 自定义的查询语句格式化函数. supportBigNumbers: 数据库处理大数字(长整型和含小数),时应该启用 (默认: false). bigNumberStrings: 启用 supportBigNumbers和bigNumberStrings 并强制这些数字以字符串的方式返回(默认: false). dateStrings: 强制日期类型(TIMESTAMP, DATETIME, DATE)以字符串返回，而不是一javascript Date对象返回. (默认: false) debug: 是否开启调试.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/oop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/oop/</guid>
      <description>Object-Oriented Programming of Javascript notes of 1 2 3
JS 的对象 JS 本身是基于对象的语言，在 JS 中所操作的基本都是对象。但在 ES2015 之前它又没有 class 的类。
如果要从原型对象生成实例对象，要把属性和方法封装到对象里。properties and methods
 对象实例  let record = { name: &amp;#34;&amp;#34;, nation: &amp;#34;&amp;#34; }; Schema 规格
let record1 = { name: &amp;#34;Alpha&amp;#34;, nation: &amp;#34;China&amp;#34; }; let record2 = { name: &amp;#34;Beta, nation: &amp;#34;Denmark&amp;#34; }; 给对象赋予属性和方法
这可以看作最简单的封装，但原型和实例间并不存在内在联系。
function Record(name, nation) { return { name: name, nation: nation, }; } let record1 = Record(&amp;#34;Alpha&amp;#34;, &amp;#34;China&amp;#34;); let record2 = Record(&amp;#34;Beta&amp;#34;, &amp;#34;Denmark&amp;#34;); 用函数调用返回对象方式可以在原型和实例间建立一定联系，但两个实例间没有内在联系。</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/performance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/performance/</guid>
      <description>Practice of JavaScript Performance Since JavaScript becomes a fullstack programming language, in certain cases the performance of JS is critical. Here are some practice of JS, with some understanding of JS implementation.
Data Store How a variable is create will effect its performance. - Use {} instead of new Object, use [] instead of new Array, use plain string instead of an object. - Use local temporary variable to store variable deep upon the data-chain, and values require many calculation.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/webpack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/webpack/</guid>
      <description>An Introduction to Webpack Webpack is a bundler for javascript, and related resources. All resources are treated as modules, and with various loaders, webpack can handle modules of CommonJs, AMD, ES6, CSS, Image, JSON, Coffeescript, LESS, etc.
// what a webpack config file &#39;webpack.config.js&#39; looks like module: { loaders: [ { test: /\.css$/, loader: &#39;style!css&#39; }, // use ! to chain loaders { test: /\.js$/, loader: &#39;jsx?harmony!babel&#39;, exclude: /node_modules/ } // loaders can be written like &#39;jsx-loader&#39; or &#39;jsx&#39; // loaders can take parameters as a querystring ] }  Entrance and output.</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>./js/z-webpack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>./js/z-webpack/</guid>
      <description>Another Webpack Note  其实Webpack的入门指导文章非常多，配置方式也各有各样，这里我推荐题叶大神的入门级指南–Webpack 入门指迷，如果不知道Webpack是什么或者不是很清楚各项配置含义的开发者，可以看此文章扫扫盲。毕竟我这篇文章并不是特别基础。 
1. base.js var path = require(&amp;lsquo;path&amp;rsquo;) var baseConfig = { resolve: { extensions: [&amp;ldquo;, &amp;lsquo;.js&amp;rsquo;], fallback: [path.join(dirname, &amp;lsquo;../node_modules&amp;rsquo;)], alias: { &amp;lsquo;src&amp;rsquo;: path.resolve(dirname, &amp;lsquo;../src&amp;rsquo;), &amp;lsquo;assets&amp;rsquo;: path.resolve(dirname, &amp;lsquo;../src/assets&amp;rsquo;), &amp;lsquo;components&amp;rsquo;: path.resolve(dirname, &amp;lsquo;../src/components&amp;rsquo;) } }, module: { loaders: [{ test: /.js$/, loader: &amp;lsquo;babel&amp;rsquo;, exclude: /node_modules/ }, { test: /.(png|jpe?g|gif|svg|woff2?|eot|ttf|otf)(\?.*)?$/, loader: &amp;lsquo;url?limit=8192&amp;amp;context=client&amp;amp;name=[path][name].[hash:7].[ext]&amp;rsquo; }, { test: /.css$/, loader: &amp;lsquo;style!css!autoprefixer&amp;rsquo;, }, { test: /.scss$/, loader: &amp;lsquo;style!css!autoprefixer!sass&amp;rsquo; }] } };</description>
    </item>
    
  </channel>
</rss>